\section{UTxO}
\label{sec:utxo}


\subsection{UTxO Transitions}
\label{sec:utxo-trans}

We have added several functions having to to with transaction and UTxO inputs and
outputs, which are used in defining the UTxO transition system. These are
given in Figure \ref{fig:functions:insouts}. These include

\begin{itemize}
  \item Functions to
sort inputs, outputs and UTxO entries into scrip and non-script.

  \item The function $\fun{txinputs_{vf}}$ returns only the inputs selected to be used
for paying script execution fees
  \item The function $\fun{txins}$ that returns $\TxIn$ part of both script
  and non-script transaction inputs.
  \item The function $\fun{outs}$ is unchanged
\end{itemize}

Figure~\ref{fig:functions:utxo} defines functions needed for the UTxO transition system.
The changes due to Plutus integration are as follows:

\begin{itemize}

  \item
    The $\fun{ubalance}$ function calculates sum total of all the coin in a given UTxO.
    (can now be applied to both script and PK-type outputs)

  \item The $\fun{consumed}$ calculation for the preservation of value remains the
  same. It is still the sum of the reward address coin consumed, the coin value
   UTxO entries consumed, and the value consumed from the deposit pot due
   to the transaction collecting deposit refunds.

  \item The $\fun{produced}$ calculation contains the fee a transaction pays
  to the fee pot, the outputs it adds to the UTxO, and the deposits it makes
  to the deposit pot (these are the same values as the ledger spec). We also
  now add the script execution fees the transaction is paying, and the deposits
  for putting a data script on-chain (this functionality is not yet fully
  implemented, decision on whether it is useful is pending).
\end{itemize}


\begin{figure}[htb]
  \begin{align*}
    & \fun{txinputs_v} \in \Tx \to \powerset{\TxIn}
    & \text{tx VK inputs} \\
    & \fun{txinputs_v} ~tx ~=~ \{ (txid,ix)~\vert~((txid,ix),b) \in
    \fun{txinputs} ~tx\cap \TxIn\}
    \nextdef
    & \fun{txinputs_{vf}} \in \Tx \to \UTxO \to \powerset{\TxIn}
    & \text{tx VK inputs used for fees} \\
    & \fun{txinputs_{vf}} ~tx~\var{utxo} ~=~ \{ (txid,ix)~\vert~((txid,ix),isf) \in
    \fun{txinputs} ~tx\cap \TxIn, \\
    & (txid,ix) \mapsto \var{txout} \in (txid,ix) \restrictdom utxo, \\
    & \fun{isf}~\var{((txid,ix),\fun{val}~\var{txout})}\in\ForFee\}
    \nextdef
    & \fun{txinputs_s} \in \Tx \to \powerset{\TxOutScr}
    & \text{tx script inputs} \\
    & \fun{txinputs_s} ~tx ~=~ \fun{txinputs} ~tx\cap \TxInScr
    \nextdef
    & \fun{txouts_s} \in \Tx \to \powerset{\TxOutScr}
    & \text{tx script outputs} \\
    & \fun{txouts_s} ~ \var{tx} =
        \left\{
          \var{ix} \mapsto \var{txout}~\in ~\txouts{tx} ~
          \middle|
          \var{txout} \in \TxOutScr
        \right\}
    \nextdef
    & \fun{txouts_v} \in \Tx \to \powerset{\TxOutVK}
    & \text{tx vk outputs} \\
    & \fun{txouts_v} ~ \var{tx} =
      \left\{
        \var{ix} \mapsto \var{txout} ~\in ~\txouts{tx}~
        \middle|
        \var{txout} \in \TxOutVK
      \right\}
    \nextdef
    & \fun{utxo_s} \in \UTxO \to \TxIn \mapsto \powerset{\TxOutScr}
    & \text{script utxo entries} \\
    & \fun{utxo_s} ~ \var{utxo} =
        \left\{
          \var{txin} \mapsto \var{txout} ~\in~ \var{utxo}~
          \middle|
          \var{txout} \in \TxOutScr
        \right\}
    \nextdef
    & \fun{outs} \in \Tx \to \UTxO
    & \text{tx outputs as UTxO} \\
    & \fun{outs} ~ \var{tx} =
        \left\{
          (\fun{txid} ~ \var{tx}, \var{ix}) \mapsto \var{txout} ~
          \middle|
          \var{ix} \mapsto \var{txout} \in \txouts{tx}
        \right\} \\
    \nextdef
    & \fun{txins} \in \Tx \to \powerset{\TxIn} & \text{transaction inputs} \\
    & \fun{txins} ~\var{tx} = \{(txid,ix) \mid (txid,ix)\in\fun{txinputs_v} ~tx\} \\
    & ~~\cup \{(txid,ix)\in\fun{txinputs_s}~ tx\} \\
  \end{align*}
  \caption{Functions on Tx Inputs and Outputs}
  \label{fig:functions:insouts}
\end{figure}


\begin{figure}[htb]
  \begin{align*}
    & \fun{ubalance} \in \UTxO \to \Coin
    & \text{UTxO balance} \\
    & \fun{ubalance} ~ utxo = \sum_{(~\wcard ~ \mapsto (\wcard, ~c)) \in \fun{utxo_v}~\var{utxo}} c \\
    &~~ + \sum_{(~\wcard ~ \mapsto (\wcard, ~c,\wcard)) \in \fun{utxo_s}~\var{utxo}} c
    \nextdef
    & \fun{wbalance} \in \Wdrl \to \Coin
    & \text{withdrawal balance} \\
    & \fun{wbalance} ~ ws = \sum_{(\wcard\mapsto c)\in\var{ws}} c
    \nextdef
    & \fun{consumed} \in \PParams \to \UTxO \to \StakeDelegs \to \Wdrl \to \Tx \to \Coin
    & \text{value consumed} \\
    & \consumed{pp}{utxo}{stdelegs}{rewards}~{tx} = \\
    & ~~\ubalance{(\txins{tx} \restrictdom \var{utxo})} +
        \fun{wbalance}~(\fun{txwdrls}~{tx}) \\
    & ~~ + \keyRefunds{pp}{stdelegs}{tx} \\
    \nextdef
    & \fun{produced} \in \PParams \to \StakePools \to \Tx \to \Coin
    & \text{value produced} \\
    & \fun{produced}~\var{pp}~\var{stpools}~\var{tx} = \\
    &~~\ubalance{(\outs{tx})}
    + \txfee{tx} + \deposits{pp}{stpools}~{(\txcerts{tx})}\\
    &~~+ \fun{scriptFees}~{pp}~\var{tx}~+~ \fun{dsDeps}~{pp}~tx
  \end{align*}
  \caption{Functions used in UTxO rules}
  \label{fig:functions:utxo}
\end{figure}

\clearpage

In the following Figure \ref{fig:functions:script} we give the functions
related to script fees.

\begin{itemize}
  \item $\fun{scriptFee}$ calculates the fee a transaction must pay
  for execution of a script (to spend from a script address).
  The actual calculation is TBD. This fee is determined as a function of

  * the execution units $\var{exunits}$, which is part of the data in
  the $txin \in \TxInTx$ (the transaction input spending the script
  UTxO entry it references). Recall that this is likely a vector of
  the quantities of the different types of resources consumed during
  validation (e.g. $\beta$-reductions, memory, etc.)

  * the cost model $costm$ protocol parameter value that gives the cost
  of using a unit of each of the types of resources which execution units is
  made up of.

  \item $\fun{scriptFees}$ adds up all the fees for all script spending
  done by a transaction

  \item $\fun{dsDep}$ and $\fun{dsDeps}$ (not currently in use) calculate
  the deposit for creating a script UTxO entry with a given data script, and
  the sum total of deposits for all new script entries a transaction is adding.
\end{itemize}

\begin{figure}[htb]
  \begin{align*}
    & \fun{scriptFee} \in \PParams \to \ExUnits \to \Coin
    & \text{script spending cost calculation} \\
    & \fun{scriptFee} ~\var{pp}~ \var{exunits} ~=~ \\
    \nextdef
    & \fun{scriptFees} \in \PParams \to \Tx \to \Coin
    & \text{fees for all scripts in Tx} \\
    & \fun{scriptFees} ~\var{pp}~\var{tx}~=~\\
    &  ~~\sum_{(\wcard,\wcard,(\wcard,\wcard,~\var{exunits})) \in(\fun{txinputs_s} ~tx)}
      \fun{scriptFee} ~\var{pp}~ \var{exunits}
    \nextdef
    & \fun{dsDep} \in \PParams \to \N \to \Coin
    & \text{deposit for script input} \\
    & \fun{dsDep} ~\var{pp}~ \var{scrsize} = scrsize*\fun{scrExecDep}~\var{pp}
    \nextdef
    & \fun{dsDeps} \in \PParams \to \Tx \to \Coin
    & \text{sum of script deposits} \\
    & \fun{dsDeps} ~\var{pp}~ \var{tx} =
      \sum_{(\wcard,script_d)\in\fun{txouts_s} ~tx}
      \fun{dsDep} ~\var{pp}~ \fun{scrsize}~{script_d}
  \end{align*}
  \caption{Script Cost Calculations}
  \label{fig:functions:script}
\end{figure}

The types for the UTxO transition are given in Figure~\ref{fig:ts-types:utxo-shelley}.
These remain unchanged.

\begin{figure}[htb]
  \emph{UTxO environment}
  \begin{equation*}
    \UTxOEnv =
    \left(
      \begin{array}{r@{~\in~}lr}
        \var{slot} & \Slot & \text{current slot}\\
        \var{pp} & \PParams & \text{protocol parameters}\\
        \var{stdelegs} & \StakeDeleg & \text{stake credential}\\
        \var{stpools} & \StakePools & \text{stake pool}\\
        \var{dms} & \KeyHashGen\mapsto\KeyHash & \text{genesis key delegations} \\
      \end{array}
    \right)
  \end{equation*}
  %
  \emph{UTxO States}
  \begin{equation*}
    \UTxOState =
    \left(
      \begin{array}{r@{~\in~}lr}
        \var{utxo} & \UTxO & \text{UTxO}\\
        \var{deposits} & \Coin & \text{deposits pot}\\
        \var{fees} & \Coin & \text{fee pot}\\
        \var{ups} & \UpdateState & \text{update state}\\
      \end{array}
    \right)
  \end{equation*}
  %
  \emph{UTxO transitions}
  \begin{equation*}
    \_ \vdash
    \var{\_} \trans{utxo}{\_} \var{\_}
    \subseteq \powerset (\UTxOEnv \times \UTxOState \times \Tx \times \UTxOState)
  \end{equation*}
  %
  \caption{UTxO transition-system types}
  \label{fig:ts-types:utxo-shelley}
\end{figure}

Figure \ref{fig:ts-types:utxo-scripts} gives the transition system for the second phase of
the two-phase script validation. The second phase means actually running
the scripts to see if they validate. Recall that scripts are only run to use a quantity of
resources limited by the values in the $\var{exunits}$. Only the fee pot and the
UTxO are affected by this validation step. The protocol parameters in the
environment are needed to calculate the total script fees in the associated
transition rules.

\begin{figure}[htb]
  \emph{Script States}
  \begin{equation*}
    \SFState =
    \left(
      \begin{array}{r@{~\in~}lr}
        \var{utxo} & \UTxO & \text{UTxO}\\
        \var{fees} & \Coin & \text{fee pot}\\
      \end{array}
    \right)
  \end{equation*}
  %
  \emph{Script transitions}
  \begin{equation*}
    \_ \vdash
    \var{\_} \trans{utxos}{\_} \var{\_}
    \subseteq \powerset (\PParams \times \SFState \times \Tx \times \SFState)
  \end{equation*}
  %
  \caption{UTxO script validation types}
  \label{fig:ts-types:utxo-scripts}
\end{figure}

The rules for the second-phase script validation are given in
Figure~\ref{fig:rules:utxo-scrval}. There are two transition rules, one of
which always applies. This is because there is a single predicate in each rule, and
the predicate for Scripts-NotVal is the negation of the predicate for
Scripts-Val. This predicate states that, for every script-spending
transaction input $txin \in \TxInTx$,

\begin{itemize}
\item Applying the validator provided by this transaction input
to the data script stored in the corresponding UTxO entry and the redeemer
script (again, provided in the transaction input), as well as the PendingTx
constructed by the $\fun{validationData}$ function, returns $\mathsf{True}$.
\item This validation computation returns $\mathsf{True}$ upon completing
the validation constrained by the resource limitations listed in $\var{exunits}$.
\item The hash of the validator provided in the transaction input is
the same as the address of the UTxO entry being spent.
\end{itemize}

Note here that the wallet is responsible to determining the $\var{exunits}$ value
by running the script itself to see how much resources it takes. It is then
also responsible for adding enough inputs to the transaction to cover the
fees required for using the resources indicated in $\var{exunits}$ (as
calculated by the $\fun{scriptFees}$ function).

For each of the two rules, the following state changes occur:

\begin{itemize}
  \item $\mathsf{Scripts-Val}$: This is the rule that applies when validation
  of all scripts in a transaction is successful. The UTxO is updated in the usual way, all
  the outputs referenced by the transaction inputs are removed, and all the
  transaction outputs are added to the UTxO, identified by the hash of
  the transaction and the index associated with the output in the transaction.
  The exact fees for script execution are added to the fee pot.

  \item $\mathsf{Scripts-NotVal}$: This rule applies when validation fails
  for one of the scripts in the transaction (only one script validation may fail,
  since validation does not proceed after this). In this case, all the
  UTxO entries corresponding to the transaction inputs selected for covering
  script fees are removed. The sum total of the value of these UTxO entries
  is added to the fee pot.
\end{itemize}


\begin{figure}[htb]
  \begin{equation}
    \inference[Scripts-Val]
    {
    \forall (txid,ix,(\var{script_v},\var{script_r},\var{exunits})) \in
      \fun{txinputs_s}~\var{tx}, \\
      (txid,ix) \mapsto ((a,c),script_d) \in \var{(txid,ix)}\restrictdom\var{utxo}, \\
      \llbracket \var{script_v} \rrbracket_{exunits} \var{script_r},\var{script_d}, \\ (\fun{validationData}~\var{utxo}~\var{tx}~
      (\fun{pendingTxIn}~\var{(txid,ix,(\var{script_v},\var{script_r},\var{exunits}))}~\var{c})) \\
      ~\wedge ~
      \fun{validatorHash}~\var{a} = \fun{scriptHash}~\var{script_v} \\
        \\
    }
    {
      \var{pp}
      \vdash
      \left(
      \begin{array}{r}
        \var{utxo} \\
        \var{fees} \\
      \end{array}
      \right)
      \trans{utxos}{tx}
      \left(
      \begin{array}{r}
        \varUpdate{\var{(\txins{tx} \subtractdom \var{utxo}) \cup \outs{tx}}}  \\
        \varUpdate{\var{fees} + \fun{scriptFees}~\var{pp}~\var{tx}} \\
      \end{array}
      \right) \\
    }
  \end{equation}
  \begin{equation}
    \inference[Scripts-NotVal]
    {\neg (
    \forall (txid,ix,(\var{script_v},\var{script_r},\var{exunits})) \in
      \fun{txinputs_s}~\var{tx}, \\
      (txid,ix) \mapsto ((a,c),script_d) \in \var{(txid,ix)}\restrictdom\var{utxo}, \\
      \llbracket \var{script_v} \rrbracket_{exunits} \var{script_r},\var{script_d}, \\ (\fun{validationData}~\var{utxo}~\var{tx}~
      (\fun{pendingTxIn}~\var{(txid,ix,(\var{script_v},\var{script_r},\var{exunits}))}~\var{c})) \\
      ~\wedge ~
      \fun{validatorHash}~\var{a} = \fun{scriptHash}~\var{script_v} ) \\
    }
    {
      \var{pp}
      \vdash
      \left(
      \begin{array}{r}
        \var{utxo} \\
        \var{fees} \\
      \end{array}
      \right)
      \trans{utxos}{tx}
      \left(
      \begin{array}{r}
        \varUpdate{\var{\fun{txinputs_{vf}}~{tx}~{utxo} \subtractdom \var{utxo}}}  \\
        \varUpdate{\var{fees} + \fun{ubalance}~(\fun{txinputs_{vf}}~{tx}~{utxo} \restrictdom \var{utxo})} \\
      \end{array}
      \right)
    }
  \end{equation}
  \caption{Script validation inference rules}
  \label{fig:rules:utxo-scrval}
\end{figure}

In Figure \ref{fig:rules:utxo-shelley}, we present the $\mathsf{UTxO-inductive}$
transition. It compares to the original rule in the Shelley ledger spec
as follows. The preconditions remain the same, with two additions:

\begin{itemize}
  \item The $\fun{scriptFees}~{pp}~\var{tx} \leq ...$ equation is added to check
  that the value of the outputs corresponding to the inputs selected
  for paying script fees indeed covers the total fee amount

  \item the UTXOS transition is added to handle UTxO updates in the presense
  of script validation constraints
\end{itemize}

Note that the types and rules for the UP transition (which is one of the
pre-conditions in the are $\mathsf{UTxO-inductive}$ rule) are not included
in this document as there is no change there due to Plutus integration.
The state change in the consequent this rule compares to the Shelley spec
as follows:

\begin{itemize}
  \item The state changes for $\var{deposits}$ and $\var{ups}$ remain
  the same as in the Shelley ledger rules.

  \item The $\var{utxo}$ state chage is now computed by the UTXOS transition
  (which is now part of the pre-conditions for this rule)

  \item The change in the $\var{fees}$ pot due to script validation is
  also computed in the UTXOS transition. However, the transaction fee, as well
  as the decayed deposit amount is added to the fee pot via this rule.

\end{itemize}

  Note that the preservation of value equation does not change depending on
  whether script validation succeeds or
  fails for some script. The accounting for the two-phase validation
  is handled in the UTXOS rule. Recall here that the preservation of value
  calculation now includes script fees.


\begin{figure}[htb]
  \begin{equation}\label{eq:utxo-inductive-shelley}
    \inference[UTxO-inductive]
    { \txttl tx \geq \var{slot}
      & \txins{tx} \neq \emptyset
      & \minfee{pp}{tx} \leq \txfee{tx}
      & \txins{tx} \subseteq \dom \var{utxo}
      \\
      \consumed{pp}{utxo}{stdelegs}{rewards}~{tx} = \produced{pp}{stpools}~{tx}
      \\
      ~
      \\
      \fun{scriptFees}~{pp}~\var{tx} \leq
      \fun{ubalance}~(\fun{txinputs_{vf}}~{tx}~{utxo} \restrictdom \var{utxo})
      \\
      ~
      \\
      {
        \left(
          \begin{array}{r}
            \var{slot} \\
            \var{pp} \\
            \var{dms} \\
          \end{array}
        \right)
      }
      \vdash \var{ups} \trans{\hyperref[fig:rules:update]{up}}{\fun{txup}~\var{tx}} \var{ups'}
      \\
      ~
      \\
      \forall (\_\mapsto (\_, c)) \in \txouts{tx}, c \geq 0
      \\
      \fun{txsize}~{tx}\leq\fun{maxTxSize}~\var{pp}
      \\
      ~
      \\
      \var{refunded} \leteq \keyRefunds{pp}{stdelegs}~{tx}
      \\
      \var{decayed} \leteq \decayedTx{pp}{stdelegs}~{tx}
      \\
      \var{depositChange} \leteq
        (\deposits{pp}~{stpools}~{\txcerts{tx}}) - (\var{refunded} + \var{decayed}) \\~\\
      \var{pp} \vdash
      {
        \left(
          \begin{array}{r}
            \var{utxo} \\
            \var{fees} \\
          \end{array}
        \right)
      }
      \trans{utxos}{\var{tx}}
      {
        \left(
          \begin{array}{r}
            \var{utxo'} \\
            \var{fees'} \\
          \end{array}
        \right)
      }
    }
    {
      \begin{array}{l}
        \var{slot}\\
        \var{pp}\\
        \var{stdelegs}\\
        \var{stpools}\\
        \var{dms}\\
      \end{array}
      \vdash
      \left(
      \begin{array}{r}
        \var{utxo} \\
        \var{deposits} \\
        \var{fees} \\
        \var{ups}\\
      \end{array}
      \right)
      \trans{utxo}{tx}
      \left(
      \begin{array}{r}
        \varUpdate{\var{utxo'}}  \\
        \varUpdate{\var{deposits} + \var{depositChange}} \\
        \varUpdate{\var{fees'} + \txfee{tx} + \var{decayed}} \\
        \varUpdate{ups'}\\
      \end{array}
      \right)
    }
  \end{equation}
  \caption{UTxO inference rules}
  \label{fig:rules:utxo-shelley}
\end{figure}

\clearpage

\begin{note}
  The deposit and refund calculations are not included in this document, and
  remain unchanged from the Shelley spec.
\end{note}

\subsection{Witnesses}
\label{sec:witnesses-shelley}

The script validation is no longer part of witnessing. Since depending on
the outcome of the validation, the UTxO itself is updated differently, we
have moved script validation from the witnessing transition and rule to
the UTXO rule. The changes we have made to the functions in Figure
\ref{fig:functions-witnesses}, as well as the transition rule in Figure
\ref{fig:rules:utxow-shelley}, are only removing any
functions, predicates, and let-bindings having to do with scripts.

Note here that witnessing (at least for spending PK outputs) must necessarily
be done before the second phase of script validation (i.e. scipt execution).
This is because script validation takes resources, the use of which must
be covered by fees regardless of whether the validation succeeds. Witnessing
guarantees that all PK outputs spending is authorized, and it is fine to
consume the PK outputs as fee payment. In the UTXOW transition rule,
this is the case. Witnessing predicates are first, followed by the UTXO transition
predicate.

\begin{figure}[htb]
  \begin{align*}
    & \fun{propWits} \in \Update \to (\KeyHashGen\mapsto\VKey) \to \powerset{\KeyHash}
    & \text{hashkeys for proposals} \\
    & \fun{propWits}~(\var{pup},~\var{aup})~\var{dms} = \\
    & ~~\left\{
      \hashKey{vkey}
      \mid
      \var{gkey}\mapsto\var{vkey}\in
      \left(\left(\dom{\var{pup}}\cup\dom{\var{aup}}\right)\restrictdom\var{dms}\right)
      \right\}
  \end{align*}

    \begin{align*}
    & \hspace{-0.8cm}\fun{witsVKeyNeeded} \in \UTxO \to \Tx \to (\KeyHashGen\mapsto\VKey) \to
      \powerset{\KeyHash}
    & \text{required key hashes} \\
    &  \hspace{-0.8cm}\fun{witsVKeyNeeded}~\var{utxo}~\var{tx}~\var{dms} = \\
    & ~~\{ \fun{paymentHK}~a \mid i \mapsto (a, \wcard) \in \var{utxo},~i\in\fun{txinsVKey}~{tx} \} \\
    \cup & ~~
           \{\fun{stakeCred_r}~a\mid a\mapsto \wcard \in \AddrRWDVKey
      \restrictdom \txwdrls{tx}\}\\
    \cup & ~~\{\cwitness{c} \mid c \in \txcerts{tx} \setminus \DCertMir\}~\cup \\
    \cup & ~~\fun{propWits}~(\fun{txup}~\var{tx})~\var{dms} \\
    \cup & ~~\bigcup_{\substack{c \in \txcerts{tx} \\ ~c \in\DCertRegPool}} \fun{poolOwners}~{c}
  \end{align*}
  \caption{Functions used in witness rule}
  \label{fig:functions-witnesses}
\end{figure}


\begin{figure}
  \begin{equation}
    \label{eq:utxo-witness-inductive-shelley}
    \inference[UTxO-wit]
    {
      (utxo, \wcard, \wcard) \leteq \var{utxoSt} \\~\\
      \forall \var{vk} \mapsto \sigma \in \txwitsVKey{tx},
      \mathcal{V}_{\var{vk}}{\serialised{\txbody{tx}}}_{\sigma} \\
      \fun{witsVKeyNeeded}~{utxo}~{tx}~{dms} \subseteq \{ \hashKey \var{vk} \mid
      \var{vk}\in\dom{(\txwitsVKey{tx})} \}
      \\~\\
      genSig \leteq
      \left\{
        \fun{hashKey}~vk \vert gkey\mapsto vk \in\var{dms}
      \right\}
      \cap
      \left\{
        \fun{hashKey}~\var{vk} \vert \var{vk}\in\dom{(\txwitsVKey{tx})}
      \right\}
      \\
      \left\{
        c\in\txcerts{tx}~\cap\DCertMir
      \right\} \neq\emptyset \implies \vert genSig\vert \geq 5 \wedge
      \fun{d}~\var{pp} > 0
      \\~\\
      {
        \begin{array}{l}
          \var{slot}\\
          \var{pp}\\
          \var{stdelegs}\\
          \var{stpools}\\
          \var{dms}\\
        \end{array}
      }
      \vdash \var{utxoSt} \trans{\hyperref[fig:rules:utxo-shelley]{utxo}}{tx}
      \var{utxoSt'}\\
    }
    {
      \begin{array}{l}
        \var{slot}\\
        \var{pp}\\
        \var{stdelegs}\\
        \var{stpools}\\
        \var{dms}\\
      \end{array}
      \vdash \var{utxoSt} \trans{utxow}{tx} \varUpdate{\var{utxoSt'}}
    }
  \end{equation}
  \caption{UTxO with witnesses inference rules}
  \label{fig:rules:utxow-shelley}
\end{figure}


\clearpage
