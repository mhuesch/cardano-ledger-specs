\section{Transactions}
\label{sec:transactions}

In Figure \ref{fig:defs:utxo-shelley-1}, we give the transaction types modified
to support Plutus scripts. These types are consistent with the Shelley ledger
as much as possible,
except for the following changes:

\begin{itemize}
  \item $\ForFee$ and $\NForFee$: These types are used to sort public key
  spending inputs in a transaction into those used to pay script validation
  fees and those not used
  for fees.

  \item $\Data$: is the type of all arguments passed to the validator script.
  \item $\ScriptV,~ \ScriptR,~ \ScriptD$: are the types of the validator,
  redeemer and data scripts.

  \item $\Info$: is the additional information an input in a transaction must
  have when spending a script output. This includes the validator and redeemer,
  as well as the resource consumption for validating spending the script output
  , expressed as $exunits$.

  \item $\TxInScr$: A transaction input spending a script output.

  \item $\TxInTx$: A transaction input (now distinct from the input $\TxIn$ in
  a UTxO entry). Can be a PK-address spending input or a script-spending input.

  \item $\TxOut,~\TxOutVK,~\TxOutScr$: An arbitrary output type (script or PK),
  as well as special output types for PK and script outputs. The script output
  includes a data script.
\end{itemize}

The types for PendingTx are added in Figure \ref{fig:defs:utxo-pending}.
These roughly match the types currently in the master plutus branch.

In Figure \ref{fig:defs:utxo-shelley-2}, the following types have changed:

\begin{itemize}
  \item $\TxBody$ was changed to have inputs of type $\TxInTx$, and the
  time to live $\Slot$ was replaced by a liveness interval $\Slot \times \Slot$,
  where the first slot is accessed by $\fun{txlst}$
  \item $\TxWitness$ is changed to exclude script witnesses. Only PK ones
  are included.
  \item $\fun{scrsize},~\fun{val},~\fun{txlst}$ accessor functions added
\end{itemize}

In Figure \ref{fig:defs:functions-valid}, functions used for script validation
are added. These are summarized below

\begin{note}
  I will adjust this to accommodate multisig.
  Note that I have excluded the native multisig from this document (termporarily,
  to focus on Plutus). I will
  bring this up in an upcoming discussion.
\end{note}

\begin{itemize}
  \item $\fun{hashScript},~ \fun{hashData},~\fun{toData}$ are hashing and encoding
  abstract functions.
  \item $\fun{isf}$ will be a concrete function that sorts transaction inputs into those
  used to pay for script execution and those that arent.
  \item $\fun{valScriptUpTo}$ is a script validation function. It takes the
  validator, redeemer and data scripts, and PendingTx as parameters. It also
  takes a term of type $\ExUnits$ as a parameter and performs validation
  \textit{limited by resource use as indicated in} $exunits$.
  \item The other functions are used to build PendingTx
\end{itemize}



\begin{figure*}[htb]
  \emph{Abstract types}
  %
  \begin{equation*}
    \begin{array}{r@{~\in~}lr}
      \var{gkey} & \VKeyGen & \text{genesis public keys}\\
      \var{gkh} & \KeyHashGen & \text{genesis key hash}\\
      \var{txid} & \TxId & \text{transaction id}\\
      \var{an} & \ApName & \text{application name}\\
      \var{st} & \SystemTag & \text{system tag}\\
      \var{ih} & \InstallerHash & \text{update data}\\
      \var{exunits} & \ExUnits & \text{units of script execution} \\
      \var{f} & \ForFee & \text{inputs intended for script fees} \\
      \var{nf} & \NForFee & \text{inputs not for script fees} \\
    \end{array}
  \end{equation*}
  \emph{Script types}
  %
  \begin{equation*}
    \begin{array}{r@{~\in~}l@{\qquad=\qquad}lr}
      \var{dat}
      & \Data
      & \mathbb{N}\uniondistinct\mathbb{H}\uniondistinct(\mathbb{N}\times\seqof{\Data})
        \uniondistinct\seqof{\Data}\uniondistinct\seqof{\Data \times \Data}
      & \text{the $\Data$ type}\\
    \end{array}
  \end{equation*}
  %
  \begin{equation*}
    \begin{array}{r@{~\in~}l@{\subset}lr}
      \var{script_v}&\ScriptV & \Script & \text{validator script}\\
      \var{script_d}&\ScriptD & \Data & \text{data script}\\
      \var{script_r}&\ScriptR & \Data & \text{redeemer script}\\
    \end{array}
  \end{equation*}
%
  \emph{Derived types}
  %
  \begin{equation*}
    \begin{array}{r@{~\in~}l@{\qquad=\qquad}lr}
      (\var{txid}, \var{ix})
      & \type{TxIn}
      & \TxId \times \Ix
      & \text{UTxO entry reference}
      \\
      \var{(\var{script_v}, \var{script_r},\var{exunits})}
      & \Info
      & \ScriptV \times \ScriptR \times \ExUnits
      & \text{validation data}
      \\
      (\var{txid}, \var{ix}, \var{inf})
      & \type{TxInScr}
      & \TxIn \times \Info
      & \text{script input}
      \\
      \var{txin}
      & \TxInTx
      & \TxIn \uniondistinct \TxInScr
      & \text{transaction input}
      \\
      \var{ptx}
      & \PendingTxInS
      & \TxIn \times (\HashScr \times \HashScr) \times \Coin
      & \text{pending Tx script input}
      \\
      (\var{addr}, c)
      & \type{TxOutVK}
      & \Addr \times \Coin
      & \text{vk address output}
      \\
      (\var{addr}, c)
      & \type{TxOutScr}
      & \type{TxOutVK} \times \ScriptD
      & \text{script address output}
      \\
      \var{txout}
      & \TxOut
      & \TxOutVK \uniondistinct \TxOutScr
      & \text{transaction outputs}
      \\
      \var{utxo}
      & \UTxO
      & \TxIn \mapsto \TxOut
      & \text{unspent tx outputs}
      \\
      \var{wdrl}
      & \Wdrl
      & \AddrRWD \mapsto \Coin
      & \text{reward withdrawal}
      \\
      \var{pup}
      & \PPUpdate
      & \KeyHashGen \mapsto \Ppm \mapsto \Seed
      & \text{PP update}
      \\
      \var{av}
      & \ApVer
      & \N
      & \text{application versions}
      \\
      \var{md}
      & \Metadata
      & \SystemTag\mapsto\InstallerHash
      & \text{application metadata}
      \\
      \var{apps}
      & \Applications
      & \ApName \mapsto (\ApVer \times \Metadata)
      & \text{application versions}
      \\
      \var{aup}
      & \AVUpdate
      & \KeyHashGen \mapsto \Applications
      & \text{application update}
      \\
      \var{up}
      & \Update
      & \PPUpdate \times \AVUpdate
      & \text{update proposal}
    \end{array}
  \end{equation*}
  \caption{Definitions used in the UTxO transition system}
  \label{fig:defs:utxo-shelley-1}
\end{figure*}

\begin{figure*}[htb]
  \emph{PendingTx Types}
  %
  \begin{equation*}
    \begin{array}{r@{~\in~}l@{\qquad=\qquad}l}
      \var{ptxiv}
      & \PendingTxInV
      & \TxIn \times \Coin
      \\
      \var{ptxis}
      & \PendingTxInS
      & \TxIn \times (\HashScr \times \HashDat) \times \Coin
      \\
      \var{ptxi}
      & \PendingTxIn
      & \PendingTxInV \uniondistinct \PendingTxInS
      \\
      \var{ptx}
      & \PendingTx
      & \powerset{\PendingTxIn} \times  \powerset{\TxOut} \times \Coin \times
      \PendingTxInS \times (\Slot\times\Slot)
      \\
    \end{array}
  \end{equation*}
  \caption{Definitions used to make PendingTx}
  \label{fig:defs:utxo-pending}
\end{figure*}

\begin{figure*}[htb]
  \emph{Transaction Types}
  %
  \begin{equation*}
    \begin{array}{r@{~\in~}l@{\qquad=\qquad}l}
      \var{txbody}
      & \TxBody
      & \powerset{\TxInTx} \times (\Ix \mapsto \TxOut) \times \seqof{\DCert}
        \times \Coin \times (\Slot\times\Slot) \times \Wdrl \times \Update
      \\
      \var{wit} & \TxWitness & (\VKey \mapsto \Sig)
      \\
      \var{tx}
      & \Tx
      & \TxBody \times \TxWitness
    \end{array}
  \end{equation*}
  %
  \emph{Accessor Functions}
  \begin{equation*}
    \begin{array}{r@{~\in~}lr}
      \fun{txinputs} & \Tx \to \powerset{\TxInTx} & \text{transaction inputs} \\
      \fun{txouts} & \Tx \to (\Ix \mapsto \TxOut) & \text{transaction outputs} \\
      \fun{txcerts} & \Tx \to \seqof{\DCert} & \text{delegation certificates} \\
      \fun{txfee} & \Tx \to \Coin & \text{transaction fee} \\
      \fun{txsize} & \Tx \to \Coin & \text{transaction size} \\
      \fun{txttl} & \Tx \to \Slot & \text{time to live} \\
      \fun{txlst} & \Tx \to \Slot & \text{start of liveness interval} \\
      \fun{txwdrls} & \Tx \to \Wdrl & \text{withdrawals} \\
      \fun{txbody} & \Tx \to \TxBody & \text{transaction body}\\
      \fun{txwitsVKey} & \Tx \to (\VKey \mapsto \Sig) & \text{VKey witnesses} \\
      \fun{txup} & \Tx \to \Update & \text{protocol parameter update} \\
      \fun{scrsize} & \ScriptD \to \Coin & \text{data size} \\
      \fun{val} & \TxOut \to \Coin & \text{output value} \\
    \end{array}
  \end{equation*}
  \caption{Definitions used in the UTxO transition system, cont.}
  \label{fig:defs:utxo-shelley-2}
\end{figure*}

\begin{figure*}[htb]
  \emph{Abstract Functions}
  %
  \begin{align*}
    \fun{hashScript} \in & \Script\to \HashScr & \text{compute script hash} \\
    \fun{hashData} \in & \Data \to \HashDat
    & \text{compute hash of data} \\
    \fun{toData} \in & \PendingTx\to \Data
    & \text{encode PendingTx as Data} \\
  \end{align*}
  \emph{Helper Functions}
  %
  \begin{align*}
    & \fun{isf} \in \TxIn \to \ForFee \uniondistinct \NForFee \\
    & \fun{isf}~\var{(txid,ix)} = \\
    &\text{calculates whether this input should be used to pay script fees}
    \\~\\
    & \fun{valScriptUpTo} \in \Script\to (\Data \times \Data \times \Data \times \ExUnits)
    \to\Bool \\ & \text{restricted validate script} \\~\\
    & \fun{pendingTxIn} \in \TxInTx \to \Coin \to \PendingTxIn \\
    & \fun{pendingTxIn}~\var{txin}~\var{c} = \\
    & \begin{cases}
          (txin,\fun{hashScript}~{script_v},\fun{hashData}~{script_v},c)
           & \text{if}~\var{txin} = ((txid,ix),(\var{script_v}, \var{script_r},\wcard)) \in \TxInScr \\
          ((txid,ix),c) & \text{if}~
           \var{txin} = ((txid,ix),\wcard) \in \TxIn
      \end{cases}\\
    & \text{build pending Tx input} \\~\\
    & \fun{mkIns} \in \Tx \to \UTxO \to \powerset{\PendingTxIn} \\
    & \fun{mkIns}~\var{tx}~\var{utxo} = \\
    & \{ \fun{pendingTxIn}~\var{txin}~\var{\fun{val}~\var{txout}} ~\vert~ \var{txin} \mapsto \var{txout}
    \in \fun{txins}~\var{tx} \restrictdom \var{utxo}\} \\
    & \text{build pending Tx inputs} \\~\\
    & \fun{validationData} \in \UTxO \to \Tx \to \PendingTxInS \to \PendingTx \\
    & \fun{validationData}~\var{utxo}~\var{tx}~\var{ptxis} = \\ &
    ((\fun{mkIns}~\var{tx}~\var{utxo}),\{ \var{txout}~\vert~ \var{ix} \mapsto \var{txout} \in \fun{txouts}~\var{tx}\},
    \fun{txfee}~{tx},\var{ptxis},(\fun{txlst}~{tx},\fun{txttl}~{tx})) \\
    & \text{build PendingTx} \\
  \end{align*}
  %
  \emph{Notation}
  %
  \begin{align*}
    \llbracket \var{script_v} \rrbracket_{\var{exunits}} \var{script_d}~\var{script_r}~\var{ptx}
    &=& \fun{valScriptUpTo} ~\var{script_v} ~ \var{script_d}~\var{script_r}~\var{ptx}~
    \var{exunits}
  \end{align*}
  \caption{Script Validation}
  \label{fig:defs:functions-valid}
\end{figure*}


\clearpage
